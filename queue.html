<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue visualizer</title>
    <link rel="stylesheet" href="quicksort.css">
</head>
<body>
    <div class="main2">
        <a href="stack.html"><button id="previous">Previous</button></a>
        <a href="dequeue.html"><button id="next">Next</button></a>
    </div>
    <div class="main">
        <div class="main1">
            <h1 style="text-decoration: double underline;">Queue Data Structure</h1><br><br>
            <ul>
                <li>A queue is a useful data structure in programming. It is similar to the ticket queue outside a cinema hall, where the first person entering the queue is the first person who gets the ticket.</li><br>
                <li>Queue follows the <b>First In First Out (FIFO)</b> rule - the item that goes in first is the item that comes out first.</li><br>

                <div class="img">
                    <img src="queue_images/queue-1.webp" >
                    <div class="text">FIFO Representation of Queue</div>
                </div>

                <li>In the above image, since 1 was kept in the queue before 2, it is the first to be removed from the queue as well. It follows the <b>FIFO</b> rule.</li><br>
                <li>In programming terms, putting items in the queue is called <b>enqueue</b>, and removing items from the queue is called <b>dequeue</b>.</li>
                <br>
            </ul>
            <br>
            <hr><br><br><br>

            <h2>Basic Operations of Queue</h2><br>
                <p>A queue is an object (an abstract data structure - ADT) that allows the following operations:</p><br>

                <ul>
                    <li><b>Enqueue:</b> Add an element to the end of the queue.</li><br>
                    <li><b>Dequeue:</b> Remove an element from the front of the queue.</li><br>
                    <li><b>IsEmpty:</b> Check if the queue is empty.</li><br>
                    <li><b>IsFull:</b> Check if the queue is full.</li><br>
                    <li><b>Peek:</b> Get the value of the front of the queue without removing it.</li><br>
                </ul><br><br><hr>
        </div>
        <div class="main2">
            <ol>
                <h2>Working of Queue</h2><br>
                <p>Queue operations work as follows:</p><br>
                <ul type="circle" id="textbox1">
                    <li>two pointers "FRONT" and "REAR".</li><br>
                    <li>"FRONT" track the last element of the queue.</li> <br>
                    <li>"REAR" track the first element of the queue.</li><br>
                    <li>initially, set value of FRONT and REAR to -1</li>
                </ul>
                <br>
                <h2>Enqueue Operation</h2><br>
                <ul>
                    <li>check if the queue is full.</li><br>
                    <li>for the first element, set the value of "FRONT" to 0.</li><br>
                    <li>increase the "REAR" index by 1.</li><br>
                    <li>add the new element in the position pointed to by "REAR"</li>
                </ul><br>
                <h2>Dequeue Operation</h2><br>
                <ul>
                    <li>check if the queue is empty.</li><br>
                    <li>return the value pointed by "FRONT".</li><br>
                    <li>increase the FRONT index by 1.</li><br>
                    <li>for the last element, reset the values of "FRONT" and "REAR" to -1</li>
                </ul><br><br>

                <div class="img">
                    <img src="queue_images/queue-2.webp" >
                    <div class="text">Enqueue and Dequeue Operations</div>
                </div>  
            <br><br><hr><br><br>
            <h2>Queue Algorithm</h2><br>
            <div id="box" style="background-color: #2d2d2d;">
                <span class="string">
                    <ol>
                        <li>START</li><br>
                        <li>Check if the queue is full.</li><br>
                        <li>If the queue is full, produce overflow error and exit.</li><br>
                        <li>If the queue is not full, increment rear pointer to point the next empty space.</li><br>
                        <li>Add data element to the queue location, where the rear is pointing.</li><br>
                        <li>return success.</li><br>
                        <li>END</li>
                    </ol>
                </span>
            </div>
            <br>
            <br>
            <hr>
            <br>
            <h2>Queue Implementations in Python, Java and C/C++</h2>
            <!-- test -->
<br>
<div class="navbar">
    <button class="tab active" onclick="showCode('python')">Python</button>
    <button class="tab" onclick="showCode('java')">Java</button>
    <button class="tab" onclick="showCode('c')">C</button>
    <button class="tab" onclick="showCode('cpp')">C++</button>
</div>

<div class="code-container">
    <!-- Python code -->
    <pre id="python" class="code-block active">
        <span class="comment"># Queue implementation in Python</span>
        <span class="keyword">class</span> Queue:
            <span class="keyword">def</span> __init__(self):
                <span class="keyword">self</span>.queue = []

            <span class="keyword">def</span> enqueue(self, item):
                <span class="keyword">self</span>.queue.append(item)

            <span class="keyword">def</span> dequeue(self):
                <span class="keyword">if</span> len(<span class="keyword">self</span>.queue) > 0:
                    <span class="keyword">return</span> <span class="keyword">self</span>.queue.pop(0)
                <span class="keyword">else</span>:
                    <span class="keyword">return</span> <span class="string">"Queue is empty"</span>

            <span class="keyword">def</span> peek(self):
                <span class="keyword">if</span> len(<span class="keyword">self</span>.queue) > 0:
                    <span class="keyword">return</span> <span class="keyword">self</span>.queue[0]
                <span class="keyword">else</span>:
                    <span class="keyword">return</span> <span class="string">"Queue is empty"</span>

            <span class="keyword">def</span> is_empty(self):
                <span class="keyword">return</span> len(<span class="keyword">self</span>.queue) == 0

        q = Queue()
        q.enqueue(10)
        q.enqueue(20)
        q.enqueue(30)
        <span class="keyword">print</span>(q.dequeue()) <span class="comment"># 10</span>
        <span class="keyword">print</span>(q.peek()) <span class="comment"># 20</span>
    </pre>

    <!-- Java code -->
    <pre id="java" class="code-block">
        <span class="comment">// Queue implementation in Java</span>
        <span class="keyword">class</span> Queue {
            <span class="keyword">int</span> front = -1;
            <span class="keyword">int</span> rear = -1;
            <span class="keyword">int</span> maxSize = 5;
            <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];

            <span class="keyword">void</span> enqueue(<span class="keyword">int</span> item) {
                <span class="keyword">if</span> (rear == maxSize - 1) {
                    <span class="keyword">System</span>.out.println(<span class="string">"Queue is full"</span>);
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (front == -1) front = 0;
                    queue[++rear] = item;
                }
            }

            <span class="keyword">int</span> dequeue() {
                <span class="keyword">if</span> (front == -1 || front > rear) {
                    <span class="keyword">System</span>.out.println(<span class="string">"Queue is empty"</span>);
                    <span class="keyword">return</span> -1;
                }
                <span class="keyword">else</span> {
                    <span class="keyword">return</span> queue[front++];
                }
            }

            <span class="keyword">int</span> peek() {
                <span class="keyword">if</span> (front == -1 || front > rear) {
                    <span class="keyword">System</span>.out.println(<span class="string">"Queue is empty"</span>);
                    <span class="keyword">return</span> -1;
                }
                <span class="keyword">else</span> {
                    <span class="keyword">return</span> queue[front];
                }
            }

            <span class="keyword">boolean</span> isEmpty() {
                <span class="keyword">return</span> (front == -1 || front > rear);
            }

            <span class="keyword">public static void</span> main(String[] args) {
                Queue q = <span class="keyword">new</span> Queue();
                q.enqueue(10);
                q.enqueue(20);
                q.enqueue(30);
                <span class="keyword">System</span>.out.println(q.dequeue()); <span class="comment">// 10</span>
                <span class="keyword">System</span>.out.println(q.peek()); <span class="comment">// 20</span>
            }
        }
    </pre>

    <!-- C code -->
    <pre id="c" class="code-block">
        <span class="comment">// Queue implementation in C</span>
        <span class="keyword">#include</span> <span class="keyword">&lt;stdio.h&gt;</span>
        <span class="keyword">#define</span> MAX 5
        <span class="keyword">int</span> queue[MAX];
        <span class="keyword">int</span> front = -1, rear = -1;

        <span class="keyword">void</span> enqueue(<span class="keyword">int</span> item) {
            <span class="keyword">if</span> (rear == MAX - 1) {
                <span class="keyword">printf</span>(<span class="string">"Queue is full"</span>);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (front == -1) front = 0;
                queue[++rear] = item;
            }
        }

        <span class="keyword">int</span> dequeue() {
            <span class="keyword">if</span> (front == -1 || front > rear) {
                <span class="keyword">printf</span>(<span class="string">"Queue is empty"</span>);
                <span class="keyword">return</span> -1;
            }
            <span class="keyword">else</span> {
                <span class="keyword">return</span> queue[front++];
            }
        }

        <span class="keyword">int</span> peek() {
            <span class="keyword">if</span> (front == -1 || front > rear) {
                <span class="keyword">printf</span>(<span class="string">"Queue is empty"</span>);
                <span class="keyword">return</span> -1;
            }
            <span class="keyword">else</span> {
                <span class="keyword">return</span> queue[front];
            }
        }

        <span class="keyword">int</span> isEmpty() {
            <span class="keyword">return</span> (front == -1 || front > rear);
        }

        <span class="keyword">int</span> main() {
            enqueue(10);
            enqueue(20);
            enqueue(30);
            <span class="keyword">printf</span>(<span class="string">"Dequeued: %d\n"</span>, dequeue());
            <span class="keyword">printf</span>(<span class="string">"Front element: %d\n"</span>, peek());
            <span class="keyword">return</span> 0;
        }
    </pre>

    <!-- C++ code -->
    <pre id="cpp" class="code-block">
        <span class="comment">// Queue implementation in C++</span>
        <span class="keyword">#include</span> <span class="keyword">&lt;iostream&gt;</span>
        <span class="keyword">using namespace</span> <span class="keyword">std;</span>

        <span class="keyword">class</span> Queue {
            <span class="keyword">int</span> front, rear;
            <span class="keyword">int</span> maxSize;
            <span class="keyword">int</span>* queue;

        public:
            Queue(<span class="keyword">int</span> size) {
                maxSize = size;
                queue = <span class="keyword">new</span> <span class="keyword">int</span>[size];
                front = -1;
                rear = -1;
            }

            <span class="keyword">void</span> enqueue(<span class="keyword">int</span> item) {
                <span class="keyword">if</span> (rear == maxSize - 1) {
                    <span class="keyword">cout</span> << <span class="string">"Queue is full"</span> << <span class="keyword">endl</span>;
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (front == -1) front = 0;
                    queue[++rear] = item;
                }
            }

            <span class="keyword">int</span> dequeue() {
                <span class="keyword">if</span> (front == -1 || front > rear) {
                    <span class="keyword">cout</span> << <span class="string">"Queue is empty"</span> << <span class="keyword">endl</span>;
                    <span class="keyword">return</span> -1;
                }
                <span class="keyword">else</span> {
                    <span class="keyword">return</span> queue[front++];
                }
            }

            <span class="keyword">int</span> peek() {
                <span class="keyword">if</span> (front == -1 || front > rear) {
                    <span class="keyword">cout</span> << <span class="string">"Queue is empty"</span> << <span class="keyword">endl</span>;
                    <span class="keyword">return</span> -1;
                }
                <span class="keyword">else</span> {
                    <span class="keyword">return</span> queue[front];
                }
            }

            <span class="keyword">bool</span> isEmpty() {
                <span class="keyword">return</span> (front == -1 || front > rear);
            }

            <span class="keyword">~Queue()</span> {
                <span class="keyword">delete</span>[] queue;
            }
        };

        <span class="keyword">int</span> main() {
            Queue q(5);
            q.enqueue(10);
            q.enqueue(20);
            q.enqueue(30);
            <span class="keyword">cout</span> << <span class="string">"Dequeued: "</span> << q.dequeue() << <span class="keyword">endl</span>;
            <span class="keyword">cout</span> << <span class="string">"Front element: "</span> << q.peek() << <span class="keyword">endl</span>;
            <span class="keyword">return</span> 0;
        }
    </pre>
</div>

<!-- test end -->

         <br>
         <hr>
         <br>
         <h2>Limitations of Queue</h2><br>
         <ul>
            <li><p>As you can see in the image below, after a bit of enqueuing and dequeuing, the size of the queue has been reduced.</p></li>
            <div class="img">
                <img src="queue_images/quue-3.webp" >
                <div class="text">Limitation of a queue</div>
            </div>
            <li><p>And we can only add indexes 0 and 1 only when the queue is reset (when all the elements have been dequeued).</p><br></li>
            <li><p>After REAR reaches the last index, if we can store extra elements in the empty spaces (0 and 1), we can make use of the empty spaces. This is implemented by a modified queue called the circular queue.</p></li>
         </ul>
         
        
        <br><br>
        <hr>
        <br>
        <h2>Complexity Analysis</h2><br>
        <ul>
            <li>The complexity of enqueue and dequeue operations in a queue using an array is O(1). If you use pop(N) in python code, then the complexity might be O(n) depending on the position of the item to be popped.
            </li>
        </ul>
        
        </ul><br><br><hr><br><br>
        <h2>Applications of Queue</h2><br>
        <ul>
            <li>CPU scheduling, Disk Scheduling</li><br>
            <li>When data is transferred asynchronously between two processes.The queue is used for synchronization. For example: IO Buffers, pipes, file IO, etc</li><br>
            <li>Handling of interrupts in real-time systems.</li><br>
            <li>Call Center phone systems use Queues to hold people calling them in order.
            </li>
        </ul><br><br><hr><br><br>
        <!-- Queue visualizer -->
        <div class="container">
            <h1>Queue Visualizer</h1>
            <div class="queue-operations">
                <input type="number" id="inputElement" placeholder="Enter a number" />
                <button onclick="enqueue()">Enqueue</button>
                <button onclick="dequeue()">Dequeue</button>
                <button onclick="peek()">Peek</button>
                <button onclick="isEmpty()">Is Empty?</button>
            </div>
    
            <div class="queue-display">
                <h2>Queue:</h2>
                <ul id="queueList"></ul>
            </div>
    
            <div id="statusMessage"></div>
        </div>
        <div class="main2">
            <a href="stack.html"><button id="previous">Previous</button></a>
        <a href="dequeue.html"><button id="next">Next</button></a>
        </div>
        </div>
    </div>
    <script src="queue.js"></script>
</body>
</html>
